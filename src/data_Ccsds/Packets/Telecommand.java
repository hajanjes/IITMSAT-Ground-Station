package data_Ccsds.Packets;

import java.io.UnsupportedEncodingException;

import data.NotImplementedException;
import data_Ccsds.Function.ArgumentNullException;
import data_Ccsds.ParameterCode.ParameterCode;
import data_Ccsds.ParameterCode.ParameterConverter;

public class Telecommand extends CcsdsPacket
{
	//#region Data Field Header (variable length)
	//#region Ack

	/// <summary>
	/// This field shall be used to indicate which acknowledgments, in the form
	/// of telecommand verification packets, shall be sent to the ground to notify
	/// acceptance and to verify execution of this telecommand packet. This shall
	/// relate only to acknowledgment of successful acceptance and execution,
	/// since failure reports are generated by default; all zeros means no success
	/// acknowledgments shall be sent.
	/// </summary>
	/// <remarks>
	/// The bit settings corresponding to these stages are as follows:
	/// ------1 (bit 3 of the Ack field set): acknowledge acceptance of the packet by the application process
	/// ----1-- (bit 2 of the Ack field set): acknowledge start of execution
	/// --1---- (bit 1 of the Ack field set): acknowledge progress of execution
	/// 1------ (bit 0 of the Ack field set): acknowledge completion of execution (whether successful or failed)
	/// </remarks>
	/// <exception cref="ArgumentOutOfRangeException">Another bit than bit 0 to 3 is set.</exception>

	private byte Ack;
	public byte getAck() {return Ack;}
	public void setAck(byte value) throws ArgumentOutOfRangeException {
		if((value & 0x0F) != value)
			throw new ArgumentOutOfRangeException("Another bit than bit 0 to 3 is set : "+value);
		else
			Ack = value;
	}
	
	/// <summary>Acknowledge acceptance of the packet by the application process.</summary>
	public boolean AckAcceptance;
	public boolean isAckAcceptance() {
		return ((Ack & 8) == 8);
	}
	public void setAckAcceptance(boolean value) {
		if(value)
			Ack |= 8;
		else
			Ack &= ((byte)~8);
	}

	/// <summary>Acknowledge start of execution.</summary>

	public boolean AckStart;
	public boolean isAckStart() {
		return ((Ack & 4) == 4);
	}
	public void AckStart(boolean value) {
		if(value)
			Ack |= 4;
		else
			Ack &= ((byte)~4);
	}
	

	/// <summary>Acknowledge progress of execution.</summary>
	public boolean AckProgress;
	public boolean isAckProgress() {
		return ((Ack & 2) == 2);
	}
	public void AckProgress(boolean value) {
		if(value)
			Ack |= 2;
		else
			Ack &= ((byte)~2);
	}
	
	/// <summary>Acknowledge completion of execution.</summary>
	public boolean AckCompletion;
	public boolean isAckCompletion() {
		return ((Ack & 1) == 1);
	}
	public void AckCompletion(boolean value) {
		if(value)
			Ack |= 1;
		else
			Ack &= ((byte)~1);
	}
	
	//#endregion

	/// <summary>This indicate the service to which the packet relate.</summary>

	public byte ServiceType; 
	public byte getServiceType() {
		return ServiceType;
	}
	public void setServiceType(byte serviceType) {
		ServiceType = serviceType;
	}

	/// <summary>
	/// Together with the service type, the subtype uniquely identifies
	/// the nature of the service request constitued by this telecommand packet.
	/// </summary>

	public byte ServiceSubtype; 
	public byte getServiceSubtype() {
		return ServiceSubtype;
	}
	public void setServiceSubtype(byte serviceSubtype) {
		ServiceSubtype = serviceSubtype;
	}

	/// <summary>This field indicates the source of the telecommand packet.</summary>

	public long SourceId;
	public long getSourceId() {
		return SourceId;
	}
	public void setSourceId(long sourceId) {
		SourceId = sourceId;
	}
	
	//#endregion

	//#region Properties
	/// <summary>Gets a value indicating whether this instance has a Packet Error Control field.</summary>
	/// <value><c>true</c> if this instance has a Packet Error Control field; otherwise, <c>false</c>.</value>
	/// <remarks><see cref="Telecommand"/> implementation always returns <c>true</c>.</remarks>
	public boolean HasPacketErrorControlField()
	{
		return true;  // PEC always present on TCs
	}

	/// <summary>Gets the alignment of the Packet Data Field in bytes.</summary>
	/// <value>The alignment of the Packet Data Field in bytes.</value>
	public int PacketDataFieldAlignment;
	public int getPacketDataFieldAlignment() {
		PacketDataFieldAlignment=EffectiveSettings.DataFieldPadding;
		return PacketDataFieldAlignment;
	}

	/// <summary>Gets or sets the global telecommand settings.</summary>
	/// <value>The global telecommand settings.</value>
	/// <remarks>
	/// These settings apply to all threads if not overriden by per-thread settings using the <see cref="Settings"/> property.
	/// 
	/// If you just want to get the effective settings, use <see cref="EffectiveSettings"/> instead.
	/// </remarks>
	public static TelecommandSettings GlobalSettings = null;
	public static TelecommandSettings getGlobalSettings() {
		return GlobalSettings;
	}
	public static void setGlobalSettings(TelecommandSettings globalSettings) {
		GlobalSettings = globalSettings;
	}

	/// <summary>Gets or sets the per-thread telecommand settings.</summary>
	/// <value>The telecommand settings.</value>
	/// <remarks>
	/// These settings are per-thread. If not set, <see cref="GlobalSettings"/> will be used.
	/// 
	/// If you just want to get the effective settings, use <see cref="EffectiveSettings"/> instead.
	/// </remarks>
	private static TelecommandSettings Settings = null;
	public static TelecommandSettings getSettings() {
		return Settings;
	}
	public static void setSettings(TelecommandSettings telecommandSettings) {
		Settings = telecommandSettings;
	}

	/// <summary>Gets the effective telecommand settings.</summary>
	public static TelecommandSettings EffectiveSettings;
	public static TelecommandSettings getEffectiveSettings() throws InvalidOperationException {
		if(Settings != null)
			return Settings;
		else if(GlobalSettings != null)
			return GlobalSettings;
		else
			throw new InvalidOperationException("No telecommand settings have been set using either Telecommand.GlobalSettings or Telecommand.Settings.");
	
	}

	
	/// <summary>Distinguish between telecommand (=1/<c>true</c>) and telemetry (=0/<c>false</c>) packets.</summary>
	/// <remarks><see cref="Telecommand"/> implementation always returns <c>true</c>.</remarks>
	public final boolean Type = true; 	
	public boolean isType() {
		return Type;
	}
	//#endregion

	//#region Constructors
	/// <summary>Initializes a new instance of the <see cref="Telecommand"/> class.</summary>
	public Telecommand() { super(); }

	/// <summary>Initializes a new instance of the <see cref="Telecommand"/> class.</summary>
	/// <param name="applicationProcessId">The Application Process ID of the <see cref="Telecommand"/>.</param>
	public Telecommand(int applicationProcessId) throws ArgumentOutOfRangeException
	{
		super();	
		setApplicationProcessId(applicationProcessId);
	}

	/// <summary>Initializes a new instance of the <see cref="Telecommand"/> class.</summary>
	/// <param name="applicationProcessId">The Application Process ID of the <see cref="Telecommand"/>.</param>
	/// <param name="ack">The Acknowledgement of the <see cref="Telecommand"/>.</param>
	/// <param name="serviceType">The Service Type of the <see cref="Telecommand"/>.</param>
	/// <param name="serviceSubtype">The Service Subtype of the <see cref="Telecommand"/>.</param>
	public Telecommand(int applicationProcessId, byte ack, byte serviceType, byte serviceSubtype) throws ArgumentOutOfRangeException
	{
		setApplicationProcessId(applicationProcessId);
		Ack = ack;
		ServiceType = serviceType;
		ServiceSubtype = serviceSubtype;
	}

	/// <summary>Initializes a new instance of the <see cref="Telecommand"/> class.</summary>
	/// <param name="applicationProcessId">The Application Process ID of the <see cref="Telecommand"/>.</param>
	/// <param name="ack">The Acknowledgement of the <see cref="Telecommand"/>.</param>
	/// <param name="serviceType">The Service Type of the <see cref="Telecommand"/>.</param>
	/// <param name="serviceSubtype">The Service Subtype of the <see cref="Telecommand"/>.</param>
	/// <param name="sequenceCount">The Sequence Count of the <see cref="Telecommand"/>.</param>
	public Telecommand(int applicationProcessId, byte ack, byte serviceType, byte serviceSubtype, int sequenceCount) throws ArgumentOutOfRangeException
	{
		setApplicationProcessId(applicationProcessId);
		Ack = ack;
		ServiceType = serviceType;
		ServiceSubtype = serviceSubtype;
		setSequenceCount(sequenceCount);
	}
	//#endregion

	//#region Methods
	/// <summary>Computes the length of the Data Field Header.</summary>
	/// <returns>The length of the Data Field Header.</returns>
	protected int ComputeDataFieldHeaderLength() throws NotSupportedException
	{
		return (int)(3 + computeDfhOptionalFieldsLength());
	}

	/// <summary>Calculates the length of the Data Field Header optional fields.</summary>
	/// <returns>The length of Data Field Header optional fields.</returns>
	private int computeDfhOptionalFieldsLength() throws NotSupportedException
	{
		TelecommandSettings settings = EffectiveSettings;

		int optionalFieldsLength = 0;

		// Source ID (only Enumerated PFCs with an integral number of bytes supported or padded _after_)
		ParameterCode sourceIdPc = settings.SourceIdPc;
		if(sourceIdPc != null)
			optionalFieldsLength += ParameterConverter.GetBitsSize(sourceIdPc);

		// Spare / DFH alignment
		int dfhAlignment = settings.DataFieldHeaderPadding; // alignment in bytes
		if(dfhAlignment != 0)
		{
			int dfhLength = optionalFieldsLength + 3; // Compute current length of DHF
			optionalFieldsLength += (dfhAlignment - (dfhLength % dfhAlignment)) % dfhAlignment; // Add missing byte count to align
		}

		return ((int)optionalFieldsLength);
	}

	/// <summary>Get the size of the telecommand in bits</summary>
	/// <returns>Size in bits</returns>
	public int GetBitsSize() throws NotSupportedException
	{
		return ComputeEntirePacketLength() * 8;
	}

	/// <summary>Convert the Data Field Header field of the current <see cref="CcsdsPacket"/> instance to bytes into the specified buffer.</summary>
	/// <param name="buffer">The destination buffer of the bytes.</param>
	/// <param name="start">The offset at which the Data Field Header starts in the buffer.</param>
	/// <returns>The number of bytes written into the buffer.</returns>
	/// <exception cref="System.ArgumentOutOfRangeException">The buffer is too small to put the data at the specified offset.</exception>
	protected int WriteDataFieldHeaderToBuffer(byte[] buffer, int start) throws NotSupportedException, UnsupportedEncodingException, ArgumentNullException, ArgumentOutOfRangeException
	{
		TelecommandSettings settings = EffectiveSettings;

		int index = start;

		// CCSDS Secondary Header Flag = 0
		// TC Packet PUS Version Number = 1
		// Ack
		buffer[index++] = (byte)(0x10 | (Ack & 0x0F));

		// Service Type (1 byte)
		buffer[index++] = ServiceType;

		// Service Subtype (1 byte)
		buffer[index++] = ServiceSubtype;

		// Source ID (only Enumerated PFCs with an integral number of bytes supported or padded _after_)
		ParameterCode sourceIdPc = settings.SourceIdPc;
		if(sourceIdPc != null)
		{
			int insertedBits = ParameterConverter.InsertValue(buffer, index * 8, SourceId, sourceIdPc);
			index += ParameterConverter.GetByteSize (insertedBits);
		}

		// DFH Spare (alignment)
		int dfhAlignment = settings.DataFieldHeaderPadding; // alignment in bytes
		if(dfhAlignment != 0)
		{
			int dfhLength = index - start; // Compute current length of DHF
			index += (dfhAlignment - (dfhLength % dfhAlignment)) % dfhAlignment; // Add missing byte count to align
		}

		// Return number of bytes written
		return index - start;
	}

	/// <summary>Reads a <see cref="Telecommand"/> packet from a buffer.</summary>
	/// <param name="buffer">The buffer containing the <see cref="Telecommand"/> packet starting at byte 0.</param>
	/// <returns>The read <see cref="Telecommand"/> packet.</returns>
	public static Telecommand FromBuffer(byte[] buffer) throws NotSupportedException, ArgumentException, InvalidChecksumException, NotImplementedException, ArgumentNullException
	{
		return FromBuffer(buffer, 0);
	}
	
	/// <summary>Reads a <see cref="Telecommand"/> packet from a buffer.</summary>
	/// <param name="buffer">The buffer containing the <see cref="Telecommand"/> packet.</param>
	/// <param name="start">The index in bytes of the start of the <see cref="Telecommand"/> packet in the buffer.</param>
	/// <returns>The read <see cref="Telecommand"/> packet.</returns>
	public static Telecommand FromBuffer(byte[] buffer, int start) throws NotSupportedException, ArgumentException, InvalidChecksumException, NotImplementedException, ArgumentNullException
	{
		TelecommandSettings settings = EffectiveSettings;

			Telecommand telecommand = new Telecommand();

			// Get checksum type from settings
			telecommand.checksumType = settings.ChecksumType;

			// Current index in bytes of the decoding (absolute to the start of the buffer) 
			int index = start;

			// Packet Header and PEC check
			telecommand.FillHeadersAndPecFromBuffer(buffer, start);
			index += getHeaderLength();

			//#region Data Field Header
			// Check CCSDS Secondary Header Flag (only support 0)
			// According to CCSDS 203.0-B-2, this bit shall be set to zero to indicate that
			// the PUS data field header is a "non-CCSDS defined secondary header".
			int ccsdsSecondaryHeaderFlag = (buffer[index] >> 7) & 0x01;
			if(ccsdsSecondaryHeaderFlag != 0)
				throw new NotSupportedException("The CCSDS Secondary Header Flag of the telecommand packet contained in the buffer is set.");

			// Check TC Packet PUS Version Number (only support 1)
			int tcPacketPusVersionNumber = (buffer[index] >> 4) & 0x07;
			if(tcPacketPusVersionNumber != 1)
				throw new NotSupportedException("The telecommand packet contained in the buffer refers to an unsupported PUS version "+tcPacketPusVersionNumber+", only 1 is supported." );

			// Ack
			telecommand.Ack = (byte)(buffer[index] & 0x0F);
			index++;

			// Service Type
			telecommand.ServiceType = buffer[index++];

			// Service Subtype
			telecommand.ServiceSubtype = buffer[index++];

			// Source ID (only Enumerated PFCs with an integral number of bytes supported or padded _after_)
			ParameterCode sourceIdPc = settings.SourceIdPc;
			if(sourceIdPc != null)
			{
				telecommand.SourceId = (long)ParameterConverter.ExtractValue(buffer, sourceIdPc, index * 8); // offset is bytes, need bits!
				index += ParameterConverter.GetByteSize(ParameterConverter.GetBitsSize(sourceIdPc));
			}

			// DFH Spare (alignment)
			int dfhAlignment = settings.DataFieldHeaderPadding; // alignment in bytes
			if(dfhAlignment != 0)
			{
				int dfhLength = index - (start + HeaderLength); // Compute current length of DHF
				index += (dfhAlignment - (dfhLength % dfhAlignment)) % dfhAlignment; // Add missing byte count to align
			}
			//#endregion

			// Data
			telecommand.FillDataFromBuffer(buffer, start, index);

			return telecommand;
		}

	/// <summary>Reads a <see cref="Telecommand"/> packet from a buffer using the specified <see cref="TelecommandSettings"/>.</summary>
	/// <param name="buffer">The buffer containing the <see cref="Telecommand"/> packet.</param>
	/// <param name="start">The index in bytes of the start of the <see cref="Telecommand"/> packet in the buffer.</param>
	/// <param name="settings">The <see cref="TelecommandSettings"/> to use to read the packet from the buffer.</param>
	/// <returns>The read <see cref="Telecommand"/> packet.</returns>
	public static Telecommand FromBuffer(byte[] buffer, int start, TelecommandSettings settings) throws NotSupportedException, ArgumentException, InvalidChecksumException, NotImplementedException, ArgumentNullException
	{
		// Save old settings and apply new ones
		TelecommandSettings oldSettings = Telecommand.Settings;
		Telecommand.Settings = settings;

		Telecommand telecommand;
		try
		{
			// Read telecommand
			telecommand = FromBuffer(buffer, start);
		}
		finally
		{
			// Put settings back
			Telecommand.Settings = oldSettings;
		}
		return telecommand;
	}
	//#endregion
	@Override
	public int PacketDataFieldAlignment() {
		PacketDataFieldAlignment=EffectiveSettings.DataFieldPadding;
		return PacketDataFieldAlignment;		
	}
}
